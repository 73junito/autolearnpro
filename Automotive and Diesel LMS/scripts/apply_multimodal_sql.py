#!/usr/bin/env python3
"""
Apply multimodal SQL updates to the Postgres database in cluster (safe, optional dry-run).

This script reads an SQL file (generated by `generate_multimodal_content.py`) and applies it
to the Postgres pod in the `autolearnpro` namespace using `kubectl exec` + `psql`.

Usage:
  python scripts/apply_multimodal_sql.py --sql scripts/data/multimodal_updates.sql [--namespace autolearnpro] [--pg-pod POD] [--dry-run] [--yes]

Options:
  --sql       Path to SQL file to apply (required)
  --namespace K8s namespace (default: autolearnpro)
  --pg-pod    Postgres pod name (optional: auto-discovered)
  --dry-run   Print actions and first 2000 chars of SQL without applying
  --yes       Skip confirmation prompt
  --timeout   Seconds for kubectl/psql commands (default: 30)

Safety features:
- Auto-discovers postgres pod if not provided and errors out if not found.
- Shows a preview of the SQL (first 2000 chars) in dry-run mode.
- Requires confirmation before applying unless `--yes` provided.
- Uses `kubectl exec -i` and pipes the SQL into `psql -U postgres -d lms_api_prod -f -`.

"""
import argparse
import subprocess
import sys
from pathlib import Path

DEFAULT_NAMESPACE = "autolearnpro"


def discover_pg_pod(namespace: str, timeout: int = 10):
    try:
        r = subprocess.run([
            "kubectl", "get", "pod", "-n", namespace,
            "-l", "app=postgres", "-o", "jsonpath={.items[0].metadata.name}"
        ], capture_output=True, text=True, timeout=timeout)
        if r.returncode != 0:
            raise RuntimeError(r.stderr.strip() or "kubectl failed")
        pod = r.stdout.strip()
        if not pod:
            raise RuntimeError("No postgres pod found via kubectl")
        return pod
    except Exception as e:
        raise RuntimeError(f"Failed to discover postgres pod: {e}")


def apply_sql_via_kubectl(pg_pod: str, namespace: str, sql_text: str, timeout: int = 30):
    # Use kubectl exec -i <pod> -- psql -U postgres -d lms_api_prod -f -
    cmd = ["kubectl", "exec", "-n", namespace, pg_pod, "--", "psql", "-U", "postgres", "-d", "lms_api_prod", "-f", "-"]
    try:
        proc = subprocess.run(cmd, input=sql_text, text=True, capture_output=True, timeout=timeout)
        return proc.returncode, proc.stdout, proc.stderr
    except subprocess.TimeoutExpired:
        return 124, "", "Timeout"


def main():
    parser = argparse.ArgumentParser(description='Apply multimodal SQL to Postgres via kubectl')
    parser.add_argument('--sql', type=Path, required=True)
    parser.add_argument('--namespace', default=DEFAULT_NAMESPACE)
    parser.add_argument('--pg-pod')
    parser.add_argument('--dry-run', action='store_true')
    parser.add_argument('--yes', action='store_true')
    parser.add_argument('--timeout', type=int, default=30)
    args = parser.parse_args()

    sql_path = args.sql
    if not sql_path.exists():
        print(f"ERROR: SQL file not found: {sql_path}")
        sys.exit(2)

    sql_text = sql_path.read_text(encoding='utf-8')

    if args.dry_run:
        print("-- DRY RUN --")
        print(f"SQL file: {sql_path} (size: {len(sql_text)} bytes)")
        print("--- Preview (first 2000 chars) ---")
        print(sql_text[:2000])
        print("--- End preview ---")
        print("Run without --dry-run and with --yes to apply.")
        return 0

    # discover pod if needed
    pg_pod = args.pg_pod
    if not pg_pod:
        try:
            pg_pod = discover_pg_pod(args.namespace, timeout=10)
            print(f"Discovered Postgres pod: {pg_pod}")
        except Exception as e:
            print(f"ERROR: {e}")
            sys.exit(3)

    # Confirmation
    if not args.yes:
        print(f"About to apply SQL to pod '{pg_pod}' in namespace '{args.namespace}'.")
        print(f"SQL file: {sql_path} (size: {len(sql_text)} bytes)")
        ans = input("Type 'apply' to continue: ")
        if ans.strip().lower() != 'apply':
            print("Aborted by user.")
            return 1

    print("Applying SQL...")
    code, out, err = apply_sql_via_kubectl(pg_pod, args.namespace, sql_text, timeout=args.timeout)
    if code == 0:
        print("SQL applied successfully.")
        if out:
            print("psql output:")
            print(out)
        return 0
    else:
        print(f"Failed to apply SQL. returncode={code}")
        if err:
            print("psql stderr:")
            print(err[:4000])
        if out:
            print("psql stdout:")
            print(out[:4000])
        return 4

if __name__ == '__main__':
    sys.exit(main())
